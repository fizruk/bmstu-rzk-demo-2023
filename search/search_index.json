{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simplicial type theory in Rzk (demo)","text":"<p>This is an Rzk demo and tutorials for the HoTT seminar at Bauman Moscow State Technical University, Nov 20\u201321, 2023 and contains a partial introduction to homotopy type theory and simplicial type theory in Rzk.</p> <p>Go to Setup and Rzk overview</p>"},{"location":"1-setup.rzk/","title":"Setup and Rzk syntax overview","text":""},{"location":"1-setup.rzk/#disclaimers","title":"Disclaimers","text":"<p>Info</p> <p>This demo is for the HoTT seminar at Bauman Moscow State Technical University, Nov 20\u201321, 2023 and contains a partial introduction to homotopy type theory and simplicial type theory in Rzk.</p> <p>Warning</p> <p>This demo relies on <code>rzk</code> version 0.6.7 and might not be up-to-date, as the proof assistant is in active development and breaking changes should be expected with further releases.</p>"},{"location":"1-setup.rzk/#installing-rzk","title":"Installing Rzk","text":"<p>To check the formalisations in this demo you can:</p> <ol> <li> <p>Have <code>rzk</code> installed locally    (the recommended way is to have VS Code extension for Rzk to handle it for you).    and running <code>rzk typecheck</code> from the root of this project (or relying on VS Code extension to typecheck all files).</p> </li> <li> <p>Use an online playground at https://rzk-lang.github.io/rzk/v0.6.7/playground/    (and copy-paste code blocks there one by one)</p> </li> </ol>"},{"location":"1-setup.rzk/#formalisation-project-structure","title":"Formalisation project structure","text":"<p>Usually, formalisation projects in Rzk consist of multiple Rzk (or literate Rzk) files. For example, this demo project has the following structure:</p> <pre><code>bmstu-rzk-demo-2023\n\u2502\n...\n\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 1-setup.rzk.md\n    \u251c\u2500\u2500 day-1\n    \u2502   \u251c\u2500\u2500 1-dependent-types.rzk.md\n    \u2502   \u251c\u2500\u2500 2-propositions-as-types.rzk.md\n    \u2502   \u251c\u2500\u2500 3-identity-types.rzk.md\n    \u2502   \u251c\u2500\u2500 4-homotopy-type-theory.rzk.md\n    \u2502   \u2514\u2500\u2500 5-exercises.rzk.md\n    \u251c\u2500\u2500 day-2\n    \u2502   \u251c\u2500\u2500 1-univalence.rzk.md\n    \u2502   \u251c\u2500\u2500 2-sets-and-logic.rzk.md\n    \u2502   \u251c\u2500\u2500 3-hott-exercises.rzk.md\n    \u2502   \u2514\u2500\u2500 4-simplicial-types.rzk.md\n    \u2514\u2500\u2500 index.md\n...\n</code></pre> <p>The formalisations are located in the <code>src/</code> directory and contain just the two literate Rzk Markdown files. For another example,  rzk-lang/sHoTT has its formalisations further split into subdirectories:</p> <pre><code>sHoTT\n\u2502\n...\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 STYLEGUIDE.md\n    \u251c\u2500\u2500 hott\n    \u2502   \u251c\u2500\u2500 00-common.rzk.md\n    \u2502   \u251c\u2500\u2500 01-paths.rzk.md\n    \u2502   \u251c\u2500\u2500 02-homotopies.rzk.md\n    \u2502   \u251c\u2500\u2500 03-equivalences.rzk.md\n    \u2502   \u251c\u2500\u2500 04-half-adjoint-equivalences.rzk.md\n    \u2502   \u251c\u2500\u2500 05-sigma.rzk.md\n    \u2502   \u251c\u2500\u2500 06-contractible.rzk.md\n    \u2502   \u251c\u2500\u2500 07-fibers.rzk.md\n    \u2502   \u251c\u2500\u2500 08-families-of-maps.rzk.md\n    \u2502   \u251c\u2500\u2500 09-propositions.rzk.md\n    \u2502   \u2514\u2500\u2500 10-trivial-fibrations.rzk.md\n    \u251c\u2500\u2500 index.md\n    \u2514\u2500\u2500 simplicial-hott\n        \u251c\u2500\u2500 03-simplicial-type-theory.rzk.md\n        \u251c\u2500\u2500 04-extension-types.rzk.md\n        \u251c\u2500\u2500 05-segal-types.rzk.md\n        \u251c\u2500\u2500 06-2cat-of-segal-types.rzk.md\n        \u251c\u2500\u2500 07-discrete.rzk.md\n        \u251c\u2500\u2500 08-covariant.rzk.md\n        \u251c\u2500\u2500 09-yoneda.rzk.md\n        \u251c\u2500\u2500 10-rezk-types.rzk.md\n        \u2514\u2500\u2500 12-cocartesian.rzk.md\n</code></pre>"},{"location":"1-setup.rzk/#running-rzk","title":"Running Rzk","text":"<p>To typecheck files, at the moment you have to run the following command in the terminal:</p> <pre><code>rzk typecheck\n</code></pre> <p>The list of files to check can be specified in <code>rzk.yaml</code> (as in this project), or listed explicitly as arguments to <code>rzk typecheck</code>:</p> <pre><code>rzk typecheck FILE-1 FILE-2 ... FILE-N\n</code></pre> <p>Warning</p> <p>It is important to pass formalisation files in the order you want them to be checked, as dependencies between files (in the form of imports) are not implemented yet.</p> <p>Tip</p> <p>Starting filenames with numbers (as in the examples above) helps automatically achieve the desired order when using wildcars (e.g. <code>rzk typecheck src/*.rzk.md</code>), although in a slightly inelegant way.</p>"},{"location":"1-setup.rzk/#literate-rzk","title":"Literate Rzk","text":"<p>If you are familiar with Markdown, then the recommended approach is to use literate Rzk Markdown, so that conventional Markdown rendering tools can be used to produce readable documentation from the formalisation files.</p> <p>For instance, this file is a literate Rzk Markdown file!</p>"},{"location":"1-setup.rzk/#syntax-overview","title":"Syntax overview","text":"<p>Each file in Rzk (or literate Rzk) must start with a declaration of the version/dialect used. We will use (the only supported) <code>rzk-1</code> dialect:</p> <pre><code>#lang rzk-1\n</code></pre> <p>The rest of the file contains primarily of <code>#define</code>-statements, each of which introduces a new definition into scope. For example, consider the following definition:</p> <pre><code>#define modus-ponens\n(A B : U)\n  : (A \u2192 B) \u2192 A \u2192 B\n  := \\ f x \u2192 f x\n</code></pre> <p>Going line by line, we have</p> <ul> <li><code>modus-ponens</code> as the name of a new definition</li> <li>two parameters \u2014 <code>A</code> and <code>B</code> (both of type <code>U</code>, meaning <code>A</code> and <code>B</code> are types<sup>1</sup>)</li> <li>declared type of <code>modus-ponens</code> is <code>(A \u2192 B) \u2192 A \u2192 B</code></li> <li>declared term (value) of <code>modus-ponens</code> is <code>\\ f x \u2192 f x</code></li> </ul> <p>Rzk typechecks the term against the declared type and, if no type errors found, remembers this definition for future use.</p>"},{"location":"1-setup.rzk/#unicode","title":"Unicode","text":"<p>Rzk supports both ASCII and Unicode versions of many syntactic constructions. We will use the following Unicode symbols:</p> <ul> <li><code>-&gt;</code> should be always replaced with <code>\u2192</code> (<code>\\to</code>)</li> <li><code>|-&gt;</code> should be always replaced with <code>\u21a6</code> (<code>\\mapsto</code>)</li> <li><code>===</code> should be always replaced with <code>\u2261</code> (<code>\\equiv</code>)</li> <li><code>&lt;=</code> should be always replaced with <code>\u2264</code> (<code>\\&lt;=</code>)</li> <li><code>/\\</code> should be always replaced with <code>\u2227</code> (<code>\\and</code>)</li> <li><code>\\/</code> should be always replaced with <code>\u2228</code> (<code>\\or</code>)</li> <li><code>0_2</code> should be always replaced with <code>0\u2082</code> (<code>0\\2</code>)</li> <li><code>1_2</code> should be always replaced with <code>1\u2082</code> (<code>1\\2</code>)</li> <li><code>I * J</code> should be always replaced with <code>I \u00d7 J</code> (<code>\\x</code> or <code>\\times</code>)</li> </ul> <p>We use ASCII versions for <code>TOP</code> and <code>BOT</code> since <code>\u22a4</code> and <code>\u22a5</code> do not read better in the code.</p>"},{"location":"1-setup.rzk/#code-style","title":"Code style","text":"<p>There is currently one large-ish project in Rzk \u2014 simplicial HoTT formalization at https://rzk-lang.github.io/sHoTT/. This project and some smaller ones adhere to the style guide which is largely influenced by <code>agda-unimath</code> and written down mostly by Fredrik Bakke.</p> <ol> <li> <p>technically, in Rzk currently <code>U</code> contains also <code>CUBE</code>, <code>TOPE</code> universes, and itself!\u00a0\u21a9</p> </li> </ol>"},{"location":"day-1/1-dependent-types.rzk/","title":"Dependent types","text":"<p>Reference material</p> <p>This page is mostly based on the introduction of dependent types in the HoTT Book (Sections 1.2\u20131.6), immediately introducing corresponding formalizations in Rzk and noting some differences.</p> <pre><code>#lang rzk-1\n</code></pre> <p>We now proceed to look at the primitives in Rzk for working with dependent types.</p>"},{"location":"day-1/1-dependent-types.rzk/#functions","title":"Functions","text":"<p>The type <code>(x : A) \u2192 B x</code> is the type of (dependent) functions with an argument of type <code>A</code> and, for each input <code>x</code>, the output type <code>B x</code>.</p> <p>As a simple example of a dependent function, consider the identity function:</p> <pre><code>#define identity\n  : ( A : U) \u2192 (x : A) \u2192 A\n  := \\ A x \u2192 x\n</code></pre> <p>Since we are not using <code>x</code> in the type of <code>identity</code>, we can simply write the type of the argument, without providing its name:</p> <pre><code>#define identity\u2081\n  : ( A : U) \u2192 A \u2192 A\n  := \\ A x \u2192 x\n</code></pre> <p>We can write this definition differently, by putting <code>(A : U)</code> into parameters (before <code>:</code>), and omitting it in the lambda abstraction:</p> <pre><code>#define identity\u2082\n( A : U)\n  : A \u2192 A\n  := \\ x \u2192 x\n</code></pre> <p>We could also move <code>x</code> into parameters as well, although this probably does not increase readability anymore:</p> <pre><code>#define identity\u2083\n( A : U)\n( x : A)\n  : A\n  := x\n</code></pre> <p>Another, less trivial example of a dependent function is the one that swaps the arguments of another function:</p> <pre><code>#define swap\n( A B C : U)\n  : (A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C)\n  := \\ f \u2192 \\ b a -&gt; f a b\n</code></pre>"},{"location":"day-1/1-dependent-types.rzk/#product-types","title":"Product types","text":"<p>Rzk does not have built-in product types, since they are a special case of \u03a3-types, which we will discuss soon. For now, we give definition of product types:</p> <pre><code>#define prod\n( A B : U)\n  : U\n  := \u03a3 (_ : A), B\n</code></pre> <p>The type <code>prod A B</code> corresponds to the product type \\(A \\times B\\). The <code>Unit</code> type corresponds to the type \\(\\mathbf{1}\\).</p> <p>The intended elements of <code>prod A B</code> are only pairs <code>(a, b) : prod A B</code> where <code>a : A</code> and <code>b : B</code>. Similarly, intended element of <code>Unit</code> is only <code>unit</code>. However, formally, this is not immediately true and instead is a theorem that we can prove.</p>"},{"location":"day-1/1-dependent-types.rzk/#remark-on-type-formers","title":"Remark on type formers","text":"<p>Formally, we have the following constituents of the definition for product types and function types (for comparison):</p> <ol> <li> <p>Type formation:</p> <ul> <li><code>prod A B</code> is a type whenever <code>A</code> and <code>B</code> are types</li> <li><code>A \u2192 B</code> is a type whenever <code>A</code> and <code>B</code> are types</li> </ul> </li> <li> <p>Constructors (introduction rules):</p> <ul> <li><code>(x , y)</code> is a term of type <code>prod A B</code> whenever <code>x : A</code> and <code>y : B</code></li> <li><code>\\ x \u2192 y</code> is a term of type <code>A \u2192 B</code> whenever for any <code>x : A</code> we have <code>y : B</code></li> </ul> </li> <li> <p>Eliminators (elimination rules):</p> <ul> <li> <p>Given <code>z : prod A B</code>, we can project the first and second components:</p> <ul> <li><code>first z : A</code> and <code>second z : B</code></li> <li> <p>it is also possible to pattern match (deconstruct) in a function argument or when introducing a parameter, e.g.</p> <pre><code>#define swap-prod\u2081\n( A B : U)\n  : prod A B \u2192 prod B A\n  := \\ (x , y) \u2192 (y , x)\n#define swap-prod\u2082\n( A B : U)\n  ( (x , y) : prod A B)\n  : prod B A\n  := ( y , x)\n</code></pre> </li> <li> <p>more generally, eliminators come in a form of an induction principle, which we will discuss below   and can be defined in Rzk in terms of pattern matching or <code>first</code> and <code>second</code>:</p> <pre><code>#define ind-prod\n( A B : U)\n( C : prod A B \u2192 U)\n( f : (a : A) \u2192 (b : B) \u2192 C (a , b))\n  : (z : prod A B) \u2192 C z\n  := \\ (a , b) \u2192 f a b\n</code></pre> </li> </ul> </li> <li> <p>Given <code>f : A \u2192 B</code>, we can apply it to an argument of type <code>a : A</code>:</p> <ul> <li><code>f a : B</code></li> </ul> </li> </ul> <p>Built-in eliminators in Rzk</p> <p>Built-in eliminators in Rzk need to be always fully applied (e.g. <code>first</code> without an argument is invalid syntax!). Technically, this corresponds with the \"second presentation\" of type theory in Appendix A.2 of the HoTT Book. In practice, this is not always convenient for users, as we often want to curry some of these built-ins, so wrapper functions are introduced (by users), for example:</p> <pre><code>#define pr\u2081\n( A B : U)\n  : prod A B \u2192 A\n  := \\ p \u2192 first p\n</code></pre> </li> <li> <p>Computation rules:</p> <ul> <li>Projecting from a pair is computed as follows for any <code>x : A</code> and <code>y : B</code>:<ul> <li><code>first (x , y) \u2261 x</code></li> <li><code>second (x , y) \u2261 y</code></li> </ul> </li> <li>Applying an lambda abstraction is computed by substituting the argument into a body:</li> <li><code>(\\ x \u2192 y) a \u2261 y{x \u21a6 a}</code> when <code>a : A</code> and for all <code>x : A</code>, <code>y : B</code>.</li> </ul> </li> <li> <p>Uniqueness principle (optional):</p> <ul> <li>For any <code>z : prod A B</code>, we have <code>z \u2261 (first z, second z)</code></li> <li>This holds definitionally for product types and \u03a3-types in Rzk, but is provable in a weaker (propositional) form in HoTT Book</li> <li>For any two functions <code>f : A \u2192 B</code> and <code>g : A \u2192 B</code>, we have <code>f \u2261 g</code> iff for any <code>x : A</code> we have <code>f x \u2261 g x</code></li> <li>This is taken in a weaker form as an Axiom 2.9.3 in HoTT Book and can also be postulated or assumed locally in Rzk (e.g. see Function extensionality in the sHoTT project)</li> </ul> </li> </ol>"},{"location":"day-1/1-dependent-types.rzk/#recursion-principle","title":"Recursion principle","text":"<p>Following the HoTT Book, for each type former we can formalize its recursion principle. A recursion principle for type <code>T</code> is a function that allows to produce a result of arbitrary type <code>C</code> from a value of type <code>T</code>:</p> <pre><code>#define rec-T\n( C : U)\n-- ... (parameters to the recursion principle)\n  : T \u2192 C\n</code></pre> <p>For example, for the product type <code>prod A B</code>, recursion principle looks like this:</p> <pre><code>#define rec-prod\n( A B : U)\n( C : U)\n( f : A \u2192 B \u2192 C)\n  : prod A B \u2192 C\n  := \\ (a , b) \u2192 f a b\n</code></pre> <p>For the <code>Unit</code> type, recursion principle is trivial:</p> <pre><code>#define rec-Unit\n( C : U)\n( c : C)\n  : Unit \u2192 C\n  := \\ unit \u2192 c\n</code></pre>"},{"location":"day-1/1-dependent-types.rzk/#induction-principle","title":"Induction principle","text":"<p>To define a dependent function out of a type, we use its induction principle, which can be seen as a dependent version of the recursion principle. An induction principle for type <code>T</code> is a function that allows to produce a result of arbitrary type <code>C z</code> from a value <code>z : T</code>:</p> <pre><code>#define ind-T\n( C : T \u2192 U)\n-- ... (parameters to the induction principle)\n  : (z : T) \u2192 C z\n</code></pre> <p>For example, for the product type <code>prod A B</code>, induction principle looks like this:</p> <pre><code>#define ind-prod\n( A B : U)\n( C : prod A B  \u2192 U)\n( f : (a : A) \u2192 (b : B) \u2192 C (a , b))\n  : (z : prod A B) \u2192 C z\n  := \\ (a , b) \u2192 f a b\n</code></pre> <p>We can use <code>ind-prod</code> to prove the uniqueness principle for products. Here we use the identity type, which we will cover later, but for now it is sufficient to know that there is always an element <code>refl_{x} : x =_{A} x</code> for any <code>x : A</code>.</p> <pre><code>#define uniq-prod\n(A B : U)\n(z : prod A B)\n  : (first z, second z) =_{prod A B} z\n  := ind-prod A B\n      ( \\ z \u2192 (first z, second z) =_{prod A B} z)\n      (\\ a b \u2192 refl_{(a , b)})\n      z\n</code></pre> <p>Since in Rzk the uniqueness principle is builtin, a simpler proof also works:</p> <pre><code>#define uniq-prod'\n(A B : U)\n(z : prod A B)\n  : (first z, second z) =_{prod A B} z\n  := refl_{z} -- works in Rzk, not in HoTT Book, since in Rzk we have (first z, second z) \u2261 z\n</code></pre> <p>For the <code>Unit</code> type, induction principle is trivial:</p> <pre><code>#define ind-Unit\n( C : Unit \u2192 U)\n( c : C unit)\n  : (z : Unit) \u2192 C z\n  := \\ unit \u2192 c\n</code></pre> <p>Unlike <code>rec-Unit</code>, induction principle for <code>Unit</code> is not useless, since it allows, for example, to prove the uniqueness principle:</p> <pre><code>#define uniq-Unit\n( z : Unit)\n  : unit =_{Unit} z\n  := ind-Unit\n      ( \\ z \u2192 unit =_{Unit} z)\n      ( refl_{unit})\n      z\n</code></pre> <p>Again, since Rzk has a builtin uniqueness principle for <code>Unit</code>, a simpler proof also works:</p> <pre><code>#define uniq-Unit'\n( z : Unit)\n  : unit =_{Unit} z\n  := refl_{z} -- works in Rzk, not in HoTT Book, since in Rzk we have unit \u2261 z\n</code></pre>"},{"location":"day-1/1-dependent-types.rzk/#dependent-pair-types-types","title":"Dependent pair types (\u03a3-types)","text":"<p>A straightforward generalization of product types to dependent pairs <code>\u03a3 (a : A), B a</code> where <code>A</code> is a type and <code>B : A \u2192 U</code> is a type family indexed in <code>A</code>.</p> <p>The indended values of <code>\u03a3 (a : A), B a</code> are pairs <code>(a , b)</code> of terms <code>a : A</code> and <code>b : B a</code>. Note that the type of the second component may depend on the value of the first component. When the type family <code>B</code> is constant, e.g. <code>(\\ _ \u2192 C)</code>, then <code>\u03a3 (a : A), B a</code> becomes exactly the product type <code>prod A C</code>.</p> <p>To eliminate dependent pairs, we use <code>first</code>, <code>second</code>, or pattern matching on pairs. However, the types of projections are less obvious compared to the case of product types.</p>"},{"location":"day-1/1-dependent-types.rzk/#projections","title":"Projections","text":"<p>The first projection can be easily defined in terms of pattern matching:</p> <pre><code>#define pr\u2081\n( A : U)\n( B : A \u2192 U)\n  : (\u03a3 (a : A), B a) \u2192 A\n  := \\ (a , _) \u2192 a\n</code></pre> <p>However, second projection requires some care. For instance, we might try this:</p> <pre><code>#define pr\u2082\n( A : U)\n( B : A \u2192 U)\n  : (\u03a3 (a : A), B a) \u2192 B a\n  := \\ (_ , b) \u2192 b\n</code></pre> <pre><code>undefined variable: a\n</code></pre> <p>We get the <code>undefined variable</code> error since <code>a</code> is not visible outside of \u03a3-type definition. To access it, we need a dependent function:</p> <pre><code>#define pr\u2082\n( A : U)\n( B : A \u2192 U)\n  : (z : \u03a3 (a : A), B a) \u2192 B (pr\u2081 A B z)\n  := \\ (_ , b) \u2192 b\n</code></pre> <p>In Rzk, it is sometimes more convenient to talk about \u03a3-types as \"total\" types (as in \"total spaces\"):</p> <pre><code>#define total-type\n( A : U)\n( B : A \u2192 U)\n  : U\n  := \u03a3 (a : A), B a\n</code></pre> <p>We can use pattern matching in the function type and this new definition to write second projection slightly differently:</p> <pre><code>#define pr\u2082'\n( A : U)\n( B : A \u2192 U)\n  : ((a, _) : total-type A B) \u2192 B a\n  := pr\u2082 A B\n</code></pre>"},{"location":"day-1/1-dependent-types.rzk/#recursion-and-induction-principles","title":"Recursion and induction principles","text":"<p>The recursion principle for \u03a3-types is a simple generalization of the recursion principle for product types:</p> <pre><code>#define rec-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : U)\n( f : (a : A) \u2192 B a \u2192 C)\n  : total-type A B \u2192 C\n  := \\ (a , b) \u2192 f a b\n</code></pre> <p>The induction principle is, again, a generalization of the recursion principle to dependent types:</p> <pre><code>#define ind-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : total-type A B \u2192 U)\n( f : (a : A) \u2192 (b : B a) \u2192 C (a , b))\n  : (z : total-type A B) \u2192 C z\n  := \\ (a , b) \u2192 f a b\n</code></pre> <p>As before, using <code>ind-\u03a3</code> we may prove the uniqueness principle, now for \u03a3-types:</p> <pre><code>#define uniq-\u03a3\n( A : U)\n( B : A \u2192 U)\n( z : total-type A B)\n  : (pr\u2081 A B z, pr\u2082 A B z) =_{total-type A B} z\n  := ind-\u03a3 A B\n      ( \\ z \u2192 (pr\u2081 A B z, pr\u2082 A B z) =_{total-type A B} z)\n      ( \\ a b \u2192 refl_{(a , b)})\n      z\n</code></pre> <p>And again, Rzk can accept a simpler proof, since uniqueness for \u03a3-types is already built into it:</p> <pre><code>#define uniq-\u03a3'\n( A : U)\n( B : A \u2192 U)\n( z : total-type A B)\n  : (pr\u2081 A B z, pr\u2082 A B z) =_{total-type A B} z\n  := refl_{z} -- works in Rzk, but not in HoTT Book\n</code></pre>"},{"location":"day-1/1-dependent-types.rzk/#type-theoretic-axiom-of-choice","title":"Type-theoretic \"axiom\" of choice","text":"<p>Using <code>ind-\u03a3</code> we can also prove a type-theoretic axiom of choice:</p> <pre><code>#define AxiomOfChoice\n  : U\n  := (A : U)\n    \u2192 (B : U)\n    \u2192 (R : A \u2192 B \u2192 U)\n    \u2192 ((x : A) \u2192 \u03a3 (y : B), R x y)\n    \u2192 (\u03a3 (f : A \u2192 B), (x : A) \u2192 R x (f x))\n</code></pre> <p>You are encouraged to try proving this yourself first.</p> <p>If you encounter problems, try looking for the proof in the HoTT Book Section 1.6 (page 32).</p> <p>If you still have issues formalizing it in Rzk, you may peek here:</p> Proof of the type theoretic axiom of choice <pre><code>#define axiom-of-choice\n  : AxiomOfChoice\n  := \\ _ B R k \u2192\n    ( \\ a \u2192 pr\u2081 B (R a) (k a)\n    , \\ a \u2192 pr\u2082 B (R a) (k a))\n</code></pre>"},{"location":"day-1/1-dependent-types.rzk/#coproducts","title":"Coproducts","text":"<p>Given types \\(A\\) and \\(B\\) a coproduct type \\(A + B\\) corresponds intuitively to a disjoint union of \\(A\\) and \\(B\\) (in set theory). We also have a nullary version: \\(\\mathbf{0}\\) (empty type).</p> <p>In Rzk, empty type and coproduct types do not exist, but a weaker version can be postulated.</p>"},{"location":"day-1/1-dependent-types.rzk/#postulating-the-empty-type","title":"Postulating the empty type","text":"<p>For example, an empty type can be postulated as follows:</p> <pre><code>#postulate Void : U\n#postulate ind-Void\n(C : Void \u2192 U)\n  : (z : Void) \u2192 C z\n</code></pre> <p>Since there should be no values of type <code>Void</code>, the induction principle corresponds to the principle that from falsehood anything follows. A non-dependent version of that corresponds to the recursion principle, which we can define in terms of <code>ind-Void</code>:</p> <pre><code>#define rec-Void\n(C : U)\n  : Void \u2192 C\n  := ind-Void (\\_ \u2192 C)\n</code></pre>"},{"location":"day-1/1-dependent-types.rzk/#postulating-the-coproduct-type","title":"Postulating the coproduct type","text":"<p>Similarly, we can postulate the coproduct:</p> <pre><code>#postulate coprod\n(A B : U)\n  : U\n</code></pre> <p>There are two ways to create a term of type <code>coprod A B</code> \u2014 inject a term from <code>A</code> or a term of <code>B</code>:</p> <pre><code>#postulate inl\n(A B : U)\n  : A \u2192 coprod A B\n#postulate inr\n(A B : U)\n  : B \u2192 coprod A B\n</code></pre> <p>To eliminate a coproduct, we have to provide two handlers \u2014 one for the left case and one for the right:</p> <pre><code>#postulate ind-coprod\n(A B : U)\n(C : coprod A B \u2192 U)\n(l : (a : A) \u2192 C (inl A B a))\n(r : (b : B) \u2192 C (inr A B b))\n  : (z : coprod A B) \u2192 C z\n</code></pre> <p>Since we are postulating the induction principle, we also have to provide the computational rules explicitly. However, in Rzk, we can only postulate propositional computational rules:</p> <pre><code>#postulate ind-coprod-inl\n(A B : U)\n(C : coprod A B \u2192 U)\n(l : (a : A) \u2192 C (inl A B a))\n(r : (b : B) \u2192 C (inr A B b))\n(a : A)\n  : ind-coprod A B C l r (inl A B a) = l a\n#postulate ind-coprod-inr\n(A B : U)\n(C : coprod A B \u2192 U)\n(l : (a : A) \u2192 C (inl A B a))\n(r : (b : B) \u2192 C (inr A B b))\n(b : B)\n  : ind-coprod A B C l r (inr A B b) = r b\n</code></pre> <p>We can now define recursion for coproducts as a special case of induction:</p> <pre><code>#define rec-coprod\n(A B : U)\n(C : U)\n(l : A \u2192 C)\n(r : B \u2192 C)\n  : coprod A B \u2192 C\n  := ind-coprod A B (\\ _ \u2192 C) l r\n</code></pre> <p>The uniqueness principle for coproducts says that any coproduct is either an <code>inl</code> or an <code>inr</code>. Proving the uniqueness is fairly straightforward, except we have to provide some intermediate types explicitly:</p> <pre><code>#define uniq-coprod\n(A B : U)\n(z : coprod A B)\n  : coprod\n(\u03a3 (a : A), inl A B a = z)\n(\u03a3 (b : B), inr A B b = z)\n  := ind-coprod A B\n( \\ z' \u2192 coprod\n          (\u03a3 (a : A), inl A B a = z')\n(\u03a3 (b : B), inr A B b = z'))\n( \\ a' \u2192 inl\n          (\u03a3 (a : A), (inl A B a = inl A B a'))\n(\u03a3 (b : B), (inr A B b = inl A B a'))\n          (a' , refl))\n( \\ b' \u2192 inr\n          (\u03a3 (a : A), (inl A B a = inr A B b'))\n(\u03a3 (b : B), (inr A B b = inr A B b'))\n          (b' , refl))\n      z\n</code></pre>"},{"location":"day-1/1-dependent-types.rzk/#booleans","title":"Booleans","text":"<pre><code>#postulate Bool : U\n#postulate false : Bool\n#postulate true : Bool\n</code></pre> <pre><code>#postulate ind-Bool\n(C : Bool \u2192 U)\n(f : C false)\n(t : C true)\n  : (z : Bool) \u2192 C z\n</code></pre> <pre><code>#postulate ind-Bool-false\n(C : Bool \u2192 U)\n(f : C false)\n(t : C true)\n  : ind-Bool C f t false = f\n#postulate ind-Bool-true\n(C : Bool \u2192 U)\n(f : C false)\n(t : C true)\n  : ind-Bool C f t true = t\n</code></pre> <pre><code>#define rec-Bool\n(C : U)\n(f t : C)\n  : Bool \u2192 C\n  := ind-Bool (\\ _ \u2192 C) f t\n</code></pre> <pre><code>#define uniq-Bool\n(z : Bool)\n  : coprod (z = false) (z = true)\n  := ind-Bool\n      ( \\ z' -&gt; coprod (z' = false) (z' = true))\n      ( inl (false = false) (false = true) refl)\n      ( inr (true = false) (true = true) refl)\n      z\n</code></pre> <pre><code>#define not\n  : Bool \u2192 Bool\n  := rec-Bool Bool true false\n</code></pre> <p>Unfortunately, because computation rules are postulated in a weak form, they do not compute automatically and have to be used explicitly, so the following proof does not work:</p> <pre><code>#define not-not-is-identity\n  : (z : Bool) \u2192 not (not z) = z\n  := ind-Bool\n      ( \\ z \u2192 not (not z) = z)\n      ( refl)\n      ( refl)\n</code></pre> <p>There is a way to fix the proof, but we'll need to learn more about the identity types before we can do that.</p>"},{"location":"day-1/1-dependent-types.rzk/#natural-numbers","title":"Natural numbers","text":"<pre><code>#postulate \u2115 : U\n#postulate zero : \u2115\n#postulate succ (n : \u2115) : \u2115\n#postulate ind-\u2115\n(C : \u2115 \u2192 U)\n(base : C zero)\n(step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : (n : \u2115) \u2192 C n\n#postulate ind-\u2115-zero\n(C : \u2115 \u2192 U)\n(base : C zero)\n(step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : ind-\u2115 C base step zero = base\n#postulate ind-\u2115-succ\n(C : \u2115 \u2192 U)\n(base : C zero)\n(step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n(n : \u2115)\n  : ind-\u2115 C base step (succ n) = step n (ind-\u2115 C base step n)\n</code></pre> <pre><code>#define rec-\u2115\n(C : U)\n(base : C)\n(step : (n : \u2115) \u2192 C \u2192 C)\n  : \u2115 \u2192 C\n  := ind-\u2115 (\\ _ \u2192 C) base step\n</code></pre> <pre><code>#define double-\u2115\n  : \u2115 \u2192 \u2115\n  := rec-\u2115 \u2115 zero (\\ _ m \u2192 succ (succ m))\n</code></pre> <pre><code>#define compute-ind-\u2115-zero\n(C : \u2115 \u2192 U)\n(base : C zero)\n(step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : C zero\n  := base\n#define compute-ind-\u2115-one\n(C : \u2115 \u2192 U)\n(base : C zero)\n(step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : C (succ zero)\n  := step zero (compute-ind-\u2115-zero C base step)\n#define compute-ind-\u2115-two\n(C : \u2115 \u2192 U)\n(base : C zero)\n(step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : C (succ (succ zero))\n  := step (succ zero) (compute-ind-\u2115-one C base step)\n#compute compute-ind-\u2115-two (\\ _ \u2192 \u2115) zero (\\ _ m \u2192 succ (succ m))\n</code></pre>"},{"location":"day-1/2-propositions-as-types.rzk/","title":"Propositions as types","text":"<p>Reference material</p> <p>This page is mostly based on the Section 1.11 of HoTT Book.</p> <pre><code>#lang rzk-1\n</code></pre> <p>Here is a quick \"cheat sheet\" relating propositions and types:</p> English Type theory Rzk True \\(\\mathbf{1}\\) <code>Unit</code> False \\(\\mathbf{0}\\) <code>Void</code> <sup>1</sup> A and B \\(A \\times B\\) <code>prod A B</code> A or B \\(A + B\\) <code>coprod A B</code> <sup>2</sup> If A then B \\(A \\to B\\) <code>A \u2192 B</code> A if and only if B \\((A \\to B) \\times (B \\to A)\\) <code>prod (A \u2192 B) (B \u2192 A)</code> Not A \\(A \\to \\mathbf{0}\\) <code>A \u2192 0</code> <sup>1</sup> For all x : A, P(x) holds \\(\\prod_{x : A} P(x)\\) <code>(x : A) \u2192 P x</code> Exists x : A such that P(x) holds \\(\\sum_{x : A} P(x)\\) <code>\u03a3 (x : A), P x</code><sup>3</sup> <pre><code>#define \u00ac (A : U) : U\n  := A \u2192 Void\n</code></pre>"},{"location":"day-1/2-propositions-as-types.rzk/#de-morgan-laws","title":"De Morgan laws","text":"<p>We can prove the following de Morgan laws:</p> <p>If not A and not B, then not (A or B).</p> <pre><code>#define neg-prod\n(A B : U)\n  : prod (\u00ac A) (\u00ac B)\n  \u2192 \u00ac (coprod A B)\n  := \\ (na , nb) \u2192 rec-coprod A B Void na nb\n</code></pre> <p>If not (A or B), then not A and not B.</p> <pre><code>#define neg-coprod\n(A B : U)\n  : \u00ac (coprod A B)\n  \u2192 prod (\u00ac A) (\u00ac B)\n  := \\ k \u2192 ( \\ a \u2192 k (inl A B a) , \\ b \u2192 k (inr A B b))\n</code></pre> <p>Not all classical tautologies are provable in HoTT:</p> <pre><code>#define classical-tauto\n(A B : U)\n  : \u00ac (prod A B) \u2192 coprod (\u00ac A) (\u00ac B)\n  := \\ k \u2192 ???\n</code></pre> <p>If for all x : A, P(x) and Q(x) then (for all x : A, P(x)) and (for all x : A, Q(x)).</p> <pre><code>#define forall-prod\n(A : U)\n(P Q : A \u2192 U)\n  : ((x : A) \u2192 prod (P x) (Q x))\n  \u2192 prod ((x : A) \u2192 P x) ((x : A) \u2192 Q x)\n  := \\ k \u2192 ( \\ x \u2192 first (k x) , \\ x \u2192 second (k x))\n</code></pre> <ol> <li> <p>Does not exist in Rzk as of v0.6.7, but can be postulated.\u00a0\u21a9\u21a9</p> </li> <li> <p>Does not exist in Rzk as of v0.6.7, but can be postulated in a weak form.\u00a0\u21a9</p> </li> <li> <p>This is only for the constructive version of \"exists\".   For the classical version, we need the propostional truncation of the \u03a3-type.   See Section 3.7 of HoTT Book for more details.\u00a0\u21a9</p> </li> </ol>"},{"location":"day-1/3-identity-types.rzk/","title":"Identity types","text":"<p>Reference material</p> <p>This page is mostly based on the Section 1.12 of HoTT Book.</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"day-1/3-identity-types.rzk/#examples-refl-and-based-induction-principle","title":"Examples, <code>refl</code>, and (based) induction principle","text":"<p>For each type <code>(A : U)</code> and elements <code>(a b : A)</code> we have the identity type <code>a =_{A} b</code> of equalities (identities, paths) between <code>a</code> and <code>b</code>.</p> <pre><code>#define FunExt\n  : U\n  := (A : U) \u2192 (B : U)\n    \u2192 (f : A \u2192 B) \u2192 (g : A \u2192 B)\n    \u2192 ((x : A) \u2192 f x =_{B} g x)\n    \u2192 (f =_{A \u2192 B} g)\n</code></pre> <p>Rzk can figure out the type indices for identity types and we can omit them:</p> <pre><code>#define FunExt\u2081 : U\n  := (A : U) \u2192 (B : U)\n    \u2192 (f : A \u2192 B) \u2192 (g : A \u2192 B)\n    \u2192 ((x : A) \u2192 f x = g x)\n    \u2192 (f = g)\n</code></pre> <p>One way to prove an equality that exists for all types, is the proof by reflexivity. For example,</p> <pre><code>#define identity-x-eq-x\n(A : U)\n(x : A)\n  : (identity A x = x)\n  := refl_{x : A}\n</code></pre> <p>Indeed, <code>identity A x</code> computes to <code>x</code>, and is therefore definitionally (computatioally) equal to it allowing for the use of <code>refl_{x : A}</code>. Again, Rzk can figure out indices accepting <code>refl_{x}</code> or just <code>refl</code>.</p> <p>Using a value of an identity type requires the path induction, which we can define via the built-in version of it, <code>idJ</code>:</p> <pre><code>#define ind-path\n(A : U)\n(a : A)\n(C : (x : A) -&gt; (a = x) -&gt; U)\n(d : C a refl)\n(b : A)\n  : (p : a = b) \u2192 C b p\n  := \\ p \u2192 idJ (A, a, C, d, b, p)\n</code></pre> <p>As an example, we can show symmetry for equality types by induction on the argument of type <code>a = b</code>:</p> <pre><code>#define inverse\n(A : U)\n(a b : A)\n  : (a = b) \u2192 (b = a)\n  := ind-path A a (\\ x _ \u2192 x = a) refl b\n</code></pre>"},{"location":"day-1/3-identity-types.rzk/#indiscernibility-of-identicals","title":"Indiscernibility of identicals","text":"<pre><code>#define indiscernibility-of-identicals\n( A : U)\n( C : A \u2192 U)\n( a x : A)\n  : (a = x)\n  \u2192 C a \u2192 C x\n  := ind-path A a\n    ( \\ z _ \u2192 (C a \u2192 C z))\n    ( \\ ca \u2192 ca)\n    x\n</code></pre>"},{"location":"day-1/3-identity-types.rzk/#not-based-path-induction","title":"Not-based path induction","text":"<pre><code>#define ind-path'\n( A : U)\n( C : (x : A) \u2192 (y : A) \u2192 (x = y) \u2192 U)\n( c : (x : A) \u2192 C x x refl_{x})\n( x y : A)\n  : (p : x = y) \u2192 C x y p\n  := ind-path A x (C x) (c x) y\n</code></pre>"},{"location":"day-1/3-identity-types.rzk/#dependent-sums-with-identity-types","title":"Dependent sums with identity types","text":"<p>The type <code>\u03a3 (x : A), B x</code> is a type of (dependent) pairs where the first component (named <code>x</code> here) is of type <code>A</code>, and the second component is of type <code>B x</code>.</p> <p>For example, preimages (fibers) of functions can be defined using <code>\u03a3</code>-types:</p> <pre><code>#define preimage\n(A B : U)\n(f : A \u2192 B)\n(y : B)\n  : U\n  := \u03a3 (x : A), (f x = y)\n</code></pre> <pre><code>#define product\n( A B : U)\n  : U\n  := \u03a3 (_ : A), B\n</code></pre>"},{"location":"day-1/4-homotopy-type-theory.rzk/","title":"Homotopy type theory","text":"<p>Reference material</p> <p>This page is mostly based on the Sections 2.1\u20132.3 of HoTT Book.</p> <pre><code>#lang rzk-1\n</code></pre> <p>In HoTT (and in Rzk), the identity type is not always a proposition and <code>refl</code> might not be the only proof of equality!</p> Type Error!<pre><code>#define does-not-typecheck\n(A : U)\n(x : A)\n(p : x = x)\n  : p = refl\n  := refl -- path induction on p also cannot work!\n</code></pre> <pre><code>#define concat\n( A : U)\n( x y z : A)\n  : (x = y) \u2192 (y = z) \u2192 (x = z)\n  := ind-path A x (\\ y' _ \u2192 (y' = z) \u2192 (x = z)) (identity (x = z)) y\n</code></pre> <p>Info</p> <p>At the moment Rzk does not have support for higher inductive types, but it is expected in the future.</p>"},{"location":"day-1/5-exercises.rzk/","title":"Exercises for Day 1","text":"<pre><code>#lang rzk-1\n</code></pre>"},{"location":"day-1/5-exercises.rzk/#dependent-types","title":"Dependent types","text":"<p>Exercise 1.1. (HoTT Book Exercise 1.1) Given functions <code>f : A \u2192 B</code> and <code>g : B \u2192 C</code>, define their composite <code>compose A B C f g : A \u2192 C</code>. Show that composition is associative (definitionally) and unital (w.r.t. <code>identity</code>).</p> <p>Exercise 1.2. (HoTT Book Exercises 1.2 and 1.3) Derive recursion and induction principles for products <code>rec-prod A B</code> using only the projections <code>pr\u2081</code> and <code>pr\u2082</code>, and verify that the definitional equalities are valid. Do the same for \u03a3-types.</p> <p>Exercise 1.3. Show that \u03a3-types are associative in the following sense:</p> <pre><code>#define reassoc-left-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : (a : A) \u2192 B a \u2192 U)\n  : (\u03a3 (a : A), \u03a3 (b : B a), C a b)\n  \u2192 (\u03a3 (ab : \u03a3 (a : A), B a), C (pr\u2081 A B ab) (pr\u2082 A B ab))\n  := ???\n#define reassoc-right-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : (a : A) \u2192 B a \u2192 U)\n  : (\u03a3 (ab : \u03a3 (a : A), B a), C (pr\u2081 A B ab) (pr\u2082 A B ab))\n  \u2192 (\u03a3 (a : A), \u03a3 (b : B a), C a b)\n  := ???\n#define assoc-left-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : (a : A) \u2192 B a \u2192 U)\n( abc : \u03a3 (a : A), \u03a3 (b : B a), C a b)\n  : reassoc-right A B C (reassoc-left A B C abc) = abc\n  := ???\n#define assoc-right-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : (a : A) \u2192 B a \u2192 U)\n( abc : \u03a3 (ab : \u03a3 (a : A), B a), C (pr\u2081 A B ab) (pr\u2082 A B ab))\n  : reassoc-left A B C (reassoc-left A B C abc) = abc\n  := ???\n</code></pre>"},{"location":"day-1/5-exercises.rzk/#propositions-as-types","title":"Propositions as types","text":"<p>Exercise 1.3. (HoTT Book Exercise 1.11) Show that for any type <code>A</code>, we have <code>\u00ac (\u00ac (\u00ac A)) \u2192 \u00ac A</code>.</p> <p>Exercise 1.4. (HoTT Book Exercises 1.12 and 1.13) Using propositions as types interpretation, prove the following tautologies:</p> <ol> <li>If A, then (if B then A).</li> <li>If A, then not (not A).</li> <li>If (not A or not B), then not (A and B).</li> <li>For any P, double negation of the law of excluded middle holds: not (not (not P or P)).</li> </ol>"},{"location":"day-1/5-exercises.rzk/#identity-types","title":"Identity types","text":"<p>Exercise 1.5. (HoTT Book Exercise 1.14) Why do the induction principles for identity types not allow us to construct a the following function?</p> <pre><code>#define bad\n  : (x : A)\n  \u2192 (p : x = x)\n  \u2192 p = refl_{x}\n  := ind-path A x _ refl_{refl_{x}}\n</code></pre>"},{"location":"day-1/5-exercises.rzk/#homotopy-type-theory","title":"Homotopy type theory","text":"<p>Exercise 1.6. Formalize both proofs of HoTT Book Lemma 2.1.1. Show that both proofs are equal.</p> <p>Exercise 1.7. Formalize both proofs of HoTT Book Lemma 2.1.2. Show that both proofs are equal.</p> <p>Exercise 1.9. Formalize the proofs of HoTT Book Lemma 2.1.3. Show that different proofs for each point in the lemma are equal.</p>"},{"location":"day-1/5-exercises.rzk/#loop-space","title":"Loop space","text":"<p>Consider the definitions of loop space and 2-loop space (HoTT Book Definition 2.1.8):</p> <pre><code>#define \u03a9\n( A : U)\n( a : A)\n  : U\n  := a =_{A} a\n#define \u03a9\u00b2\n( A : U)\n( a : A)\n  : U\n  := \u03a9 (\u03a9 A a) refl_{a}\n#define concat-\u03a9\n( A : U)\n( a : A)\n  : \u03a9 A a \u2192 \u03a9 A a \u2192 \u03a9 A a\n  := concat A a a a\n</code></pre> <p>Exercise 1.10. Formalize the proof of HoTT Book Theorem 2.1.6 (Eckmann-Hilton):</p> <pre><code>#define Eckmann-Hilton\n( A : U)\n( a : A)\n( \u03b1 \u03b2 : \u03a9 A a)\n  : concat-\u03a9 A a \u03b1 \u03b2 = concat-\u03a9 A a \u03b2 \u03b1\n  := ???\n</code></pre>"},{"location":"day-2/1-univalence.rzk/","title":"Univalence","text":"<pre><code>#lang rzk-1\n</code></pre>"},{"location":"day-2/2-sets-and-logic.rzk/","title":"Sets and Logic in HoTT","text":"<pre><code>#lang rzk-1\n</code></pre>"},{"location":"day-2/3-hott-exercises.rzk/","title":"Exercises for Day 2","text":"<pre><code>#lang rzk-1\n</code></pre>"},{"location":"day-2/4-simplicial-types.rzk/","title":"Introduction to simplicial HoTT and synthetic \u221e-categories","text":"<pre><code>#lang rzk-1\n</code></pre>"},{"location":"day-2/4-simplicial-types.rzk/#simplicial-types-with-rzk","title":"Simplicial types with Rzk","text":"<p>Following Riehl\u2013Shulman's paper<sup>1</sup>, Rzk has cube and tope layers<sup>2</sup>. These provide the ability to specify (higher) diagram schemas.</p> <p>For the purposes of his demo, we will only care about the directed interval cube <code>2</code>, 2-dimensional directed cube <code>(2 \u00d7 2)</code>, and 3-dimensional directed cube <code>(2 \u00d7 2 \u00d7 2)</code>.</p> <p>A cube may have points in it, and the directed interval <code>2</code> has two known points <code>0\u2082 : 2</code> and <code>1\u2082 : 2</code>.</p>"},{"location":"day-2/4-simplicial-types.rzk/#tope-layer","title":"Tope layer","text":"<p>Tope layer adds logical constraints on the points in a cube, \"carving out\" a shape inside a space. There is a handful of ways to specify topes:</p> <ul> <li><code>TOP</code> selects all points (provides no constraints)</li> <li><code>BOT</code> selects no points (producing an empty shape)</li> <li><code>(\u03c6 \u2227 \u03c8)</code> selects all points that satisfy both <code>\u03c6</code> and <code>\u03c8</code></li> <li><code>(\u03c6 \u2228 \u03c8)</code> selects all points that satisfy <code>\u03c6</code> or <code>\u03c8</code> (or both)</li> <li><code>(t \u2261 s)</code> selects all points such that <code>t</code> is equal to <code>s</code></li> <li><code>(t \u2264 s)</code> selects all points such that <code>t \u2264 s</code> (only when both <code>t</code> and <code>s</code> are in <code>2</code>)</li> </ul> <p>Mostly for technical reasons, we define shapes as mappings from cubes into the <code>TOPE</code> universe. For example, here is a shape that carves a (directed) triangle out of a (directed) square:</p> <p> \u2022 \u2022 \u2022 </p> <pre><code>#define \u0394\u00b9\n  : 2 \u2192 TOPE\n  := \\ _ \u2192 TOP\n#define \u0394\u00b2\n  : (2 \u00d7 2) \u2192 TOPE\n  := \\ (t, s) \u2192 (s \u2264 t)\n</code></pre> <p>For another example, here is a 3-dimensional simplex:</p> <p> \u2022 \u2022 \u2022 \u2022 </p> <pre><code>#define \u0394\u00b3\n  : (2 \u00d7 2 \u00d7 2) \u2192 TOPE\n  := \\ ((t\u2081, t\u2082), t\u2083) \u2192 (t\u2083 \u2264 t\u2082) \u2227 (t\u2082 \u2264 t\u2081)\n</code></pre> <p>Yet another example would be the horn shape that only takes two edges of a square:</p> <p> \u2022 \u2022 \u2022 </p> <pre><code>#define \u039b\n  : (2 \u00d7 2) \u2192 TOPE\n  := \\ (t, s) \u2192 (s \u2261 0\u2082) \u2228 (t \u2261 1\u2082)\n</code></pre> <p>We could refine this definition by specifying that it is a subshape of <code>\u0394\u00b2</code>:</p> <pre><code>#define \u039b'\n  : ( (t, s) : 2 \u00d7 2 | \u0394\u00b2 (t, s) ) \u2192 TOPE\n  := \\ (t, s) \u2192 (s \u2261 0\u2082) \u2228 (t \u2261 1\u2082)\n</code></pre> <p>Since shapes have the information about the cube in their types, Rzk provides an implicit coercion, allowing shorter definitions:</p> <pre><code>#define \u039b''\n  : \u0394\u00b2 \u2192 TOPE\n  := \\ (t, s) \u2192 (s \u2261 0\u2082) \u2228 (t \u2261 1\u2082)\n</code></pre> <p>Note</p> <p>This more precise type expresses a restriction on the definition of <code>\u039b''</code>, but, perhaps counterintuitively, not on the input points! With this type, Rzk additionally checks that <code>(s \u2261 0) \u2228 (t \u2261 1)</code> implies <code>\u0394\u00b2 (t, s)</code> for all <code>t</code>, <code>s</code>. However, we can still apply <code>\u039b''</code> to all points in the cube <code>(2 \u00d7 2)</code>.</p> <p>Mapping from a shape into a type, effectively selects a concrete diagram in it. We can select a subdiagram, simply by restricting to a subshape:</p> <p> f f f f f f f f f f f </p> <pre><code>#define horn-restriction\n(A : U)\n  : (f : \u0394\u00b2 \u2192 A) \u2192 (\u039b \u2192 A)\n  := \\ f t \u2192 f t\n</code></pre> <p>To construct diagrams from parts, we can use <code>recOR</code> by specifying values for several shapes. Rzk will be checking that provided values agree (definitionally) on the intersections of these shapes.</p> <p>For example, given a triangle, we can construct a square:</p> <p> recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 \u2022 \u2022 \u2022 \u2022 </p> <pre><code>#define unfolding-square\n(A : U)\n(triangle : \u0394\u00b2 \u2192 A)\n  : (2 \u00d7 2) \u2192 A\n  :=\n    \\ (t, s) \u2192\nrecOR\n      ( t \u2264 s \u21a6 triangle (s , t) ,\n        s \u2264 t \u21a6 triangle (t , s))\n</code></pre>"},{"location":"day-2/4-simplicial-types.rzk/#extension-types-with-rzk","title":"Extension types with Rzk","text":"<p>Mapping from a shape into a type, we get a diagram. To fix some parts of the diagram, we can specify refinements \u2014 for each subshape we want to fix, we provide an explicit term of the proper type.</p> <p>For example, taking a diagram in <code>A</code> correspoding to the directed interval <code>2</code> and fixing the endpoints, we get the type of all arrows between two given points in <code>A</code>:</p> <p> x y </p> <pre><code>#define hom\n(A : U)\n(x y : A)\n  : U\n  := (t : 2) \u2192\n    A [ t \u2261 0\u2082 \u21a6 x\n      , t \u2261 1\u2082 \u21a6 y ]\n</code></pre> <p>Note that this is different from the following type, since in <code>hom</code> endpoints are <code>x</code> and <code>y</code> definitionally, where as <code>pseudo-hom</code> carries proofs of equality and requires extra bookkeeping:</p> <pre><code>#define pseudo-hom\n(A : U)\n(x y : A)\n  : U\n  := \u03a3 (f : 2 \u2192 A), product (f 0\u2082 = x) (f 1\u2082 = y)\n</code></pre> <p>Another common example of an extension type would be the <code>hom2</code> type of composites of arrows:</p> <p> f f g g x y z </p> <pre><code>#define hom2\n(A : U)\n(x y z : A)\n(f : hom A x y)\n(g : hom A y z)\n  : U\n  := ((t, s) : \u0394\u00b2) \u2192\n    A [ s \u2261 0\u2082 \u21a6 f t\n      , t \u2261 1\u2082 \u21a6 g s ]\n</code></pre>"},{"location":"day-2/4-simplicial-types.rzk/#equivalences","title":"Equivalences","text":"<pre><code>#def is-equiv\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := product\n(\u03a3 (s : B \u2192 A) , (b : B) \u2192 (f (s b) = b))\n(\u03a3 (r : B \u2192 A) , (a : A) \u2192 (r (f a) = a))\n#def Equiv\n( A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B) , (is-equiv A B f)\n</code></pre>"},{"location":"day-2/4-simplicial-types.rzk/#cofibration-composition","title":"Cofibration composition","text":"<p>A useful theorem about extension types says that any extension type is equivalent to an extension of its restriction.</p> RS17, Theorem 4.4<pre><code>#def cofibration-composition\n( I : CUBE)\n( \u03c7 : I \u2192 TOPE)\n( \u03c8 : \u03c7 \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( X : \u03c7 \u2192 U)\n( a : (t : \u03d5) \u2192 X t)\n  : Equiv\n( (t : \u03c7) \u2192 X t [\u03d5 t \u21a6 a t])\n( \u03a3 ( f : (t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t]) ,\n( (t : \u03c7) \u2192 X t [\u03c8 t \u21a6 f t]))\n  :=\n    ( \\ h \u2192 (\\ t \u2192 h t , \\ t \u2192 h t) ,\n      ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl) ,\n        ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl))))\n</code></pre> <p> <p></p> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> <li> <p>Instead of builtin layers, Rzk uses <code>CUBE</code> and <code>TOPE</code> universes to separate them from the types.\u00a0\u21a9</p> </li> </ol>"}]}